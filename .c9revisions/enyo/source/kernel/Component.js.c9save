{"ts":1357127056775,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\r\n\t_enyo.Component_ is the fundamental building block for Enyo applications.\r\n\tComponents are designed to fit together, so that complex behaviors may be\r\n\tfashioned from smaller bits of functionality.\r\n\r\n\tComponent constructors take a single argument (sometimes called a\r\n\t_Component configuration_), a JavaScript object that defines various\r\n\tproperties to be initialized on the Component. For example:\r\n\r\n\t\t// create a new component, initialize its name property to 'me'.\r\n\t\tvar c = new enyo.Component({\r\n\t\t\tname: \"me\"\r\n\t\t});\r\n\r\n\tWhen a Component is instantiated, items configured in its _components_\r\n\tproperty are instantiated, too:\r\n\r\n\t\t// create a new component, which itself has a component\r\n\t\tvar c = new enyo.Component({\r\n\t\t\tname: \"me\",\r\n\t\t\tcomponents: [\r\n\t\t\t\t{kind: \"Component\", name: \"other\"}\r\n\t\t\t]\r\n\t\t});\r\n\r\n\tIn this case, when _me_ is created, _other_ is also created, and we say that\r\n\t_me owns other_. In other words, the _owner_ property of _other_ equals\r\n\t_me_. Notice that you can specify the _kind_ of _other_ explicitly in its\r\n\tconfiguration block, to tell _me_ what constructor to use to create _other_.\r\n\r\n\tNote that _kind_ values may be references to actual kinds or string-names of\r\n\tkinds. Kind names that\tdo not resolve directly to kinds are looked up in\r\n\tdefault namespaces. In this case, _kind: \"Component\"_ resolves to\r\n\t_enyo.Component_.\r\n\r\n\tTo move a component, use the _setOwner_ method to change the component's owner.\r\n\tIf you want to make a component unowned, use _setOwner(null)_.\r\n\r\n\tIf you make changes to _enyo.Component_, be sure to add or update the\r\n\tappropriate\t[unit tests](https://github.com/enyojs/enyo/tree/master/tools/test/core/tests).\r\n\r\n\tFor more information, see the documentation on\r\n\t[Components](https://github.com/enyojs/enyo/wiki/Creating-Components)\r\n\tin the Enyo Developer Guide.\r\n*/\r\nenyo.kind({\r\n\tname: \"enyo.Component\",\r\n\tkind: enyo.Object,\r\n\tpublished: {\r\n\t\t/**\r\n\t\t\tA unique name for the component within its owner. This is used to\r\n\t\t\tset the access name in the owner's _$_ hash.  If not specified, a\r\n\t\t\tdefault name will be provided based on the name of the object's\r\n\t\t\tkind, optionally with a number suffix if more than one instance\r\n\t\t\texists in the owner.\r\n\t\t*/\r\n\t\tname: \"\",\r\n\t\t/**\r\n\t\t\tA unique id for the component, usually automatically generated based\r\n\t\t\ton its position within the component hierarchy, although it may also\r\n\t\t\tbe directly specified. _enyo.Control_ uses this id value for the DOM\r\n\t\t\tid attribute.\r\n\t\t*/\r\n\t\tid: \"\",\r\n\t\t/**\r\n\t\t\tThe component that owns this component. It is usually implicitly\r\n\t\t\tdefined\tduring creation based on the _createComponent_ call or\r\n\t\t\t_components_ hash.\r\n\t\t*/\r\n\t\towner: null\r\n\t},\r\n\t//* @protected\r\n\tstatics: {\r\n\t\t// for memoizing kind-prefix names in nameComponent\r\n\t\t_kindPrefixi: {},\r\n\t\t// for naming the unnamed\r\n\t\t_unnamedKindNumber: 0\r\n\t},\r\n\tdefaultKind: \"Component\",\r\n\thandlers: {},\r\n\ttoString: function() {\r\n\t\treturn this.kindName;\r\n\t},\r\n\tconstructor: function() {\r\n\t\t// initialize instance objects\r\n\t\tthis._componentNameMap = {};\r\n\t\tthis.$ = {};\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\tconstructed: function(inProps) {\r\n\t\t// entire constructor chain has fired, now start creation chain\r\n\t\t// process instance properties\r\n\t\tthis.importProps(inProps);\r\n\t\t// perform initialization\r\n\t\tthis.create();\r\n\t},\r\n\t//* @protected\r\n\timportProps: function(inProps) {\r\n\t\tif (inProps) {\r\n\t\t\tfor (var n in inProps) {\r\n\t\t\t\tthis[n] = inProps[n];\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.handlers = enyo.mixin(enyo.clone(this.kindHandlers), this.handlers);\r\n\t},\r\n\tcreate: function() {\r\n\t\tthis.ownerChanged();\r\n\t\tthis.initComponents();\r\n\t},\r\n\tinitComponents: function() {\r\n\t\t// 'components' property in kind declarations is renamed to 'kindComponents'\r\n\t\t// by the Component subclass mechanism, allowing us to distinguish them easily\r\n\t\t// from this.components, without the code-writer having to worry about the\r\n\t\t// difference.\r\n\t\t// Specifically, the difference is that kindComponents are constructed\r\n\t\t// as owned by this control (and this.components are not).\r\n\t\t// Also, kindComponents are marked with isChrome true flag.\r\n\t\tthis.createChrome(this.kindComponents);\r\n\t\tthis.createClientComponents(this.components);\r\n\t},\r\n\tcreateChrome: function(inComponents) {\r\n\t\tthis.createComponents(inComponents, {isChrome: true});\r\n\t},\r\n\tcreateClientComponents: function(inComponents) {\r\n\t\tthis.createComponents(inComponents, {owner: this.getInstanceOwner()});\r\n\t},\r\n\tgetInstanceOwner: function() {\r\n\t\treturn (!this.owner || this.owner.notInstanceOwner) ? this : this.owner;\r\n\t},\r\n\t//* @public\r\n\t/**\r\n\t\tRemoves this component from its owner (sets _owner_ to null) and does\r\n\t\tany\tcleanup. The component is flagged with a _destroyed: true_ property.\r\n\t\tUsually the component will be suitable for garbage collection after\r\n\t\tbeing destroyed, unless user code keeps a reference to it.\r\n\t*/\r\n\tdestroy: function() {\r\n\t\tthis.destroyComponents();\r\n\t\tthis.setOwner(null);\r\n\t\t// JS objects are never truly destroyed (GC'd) until all references are gone,\r\n\t\t// we might have some delayed action on this object that needs to have access\r\n\t\t// to this flag.\r\n\t\tthis.destroyed = true;\r\n\t},\r\n\t/**\r\n\t\tDestroys all owned components.\r\n\t*/\r\n\tdestroyComponents: function() {\r\n\t\tenyo.forEach(this.getComponents(), function(c) {\r\n\t\t\t// This local components list may be stale as components\r\n\t\t\t// we owned when the loop started could have been destroyed\r\n\t\t\t// by containers. Avoid redestroying components by testing\r\n\t\t\t// destroyed flag.\r\n\t\t\tif (!c.destroyed) {\r\n\t\t\t\tc.destroy();\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\t//* @protected\r\n\tmakeId: function() {\r\n\t\tvar delim = \"_\", pre = this.owner && this.owner.getId();\r\n\t\tvar baseName = this.name || (\"@@\" + (++enyo.Component._unnamedKindNumber));\r\n\t\treturn (pre ? pre + delim : \"\") + baseName;\r\n\t},\r\n\townerChanged: function(inOldOwner) {\r\n\t\tif (inOldOwner) {\r\n\t\t\tinOldOwner.removeComponent(this);\r\n\t\t}\r\n\t\tif (this.owner) {\r\n\t\t\tthis.owner.addComponent(this);\r\n\t\t}\r\n\t\tif (!this.id) {\r\n\t\t\tthis.id = this.makeId();\r\n\t\t}\r\n\t\t//this.id = this.makeId();\r\n\t},\r\n\tnameComponent: function(inComponent) {\r\n\t\tvar prefix = enyo.Component.prefixFromKindName(inComponent.kindName);\r\n\t\t// get last memoized name index\r\n\t\tvar n, i = this._componentNameMap[prefix] || 0;\r\n\t\t// find an available name\r\n\t\tdo {\r\n\t\t\tn = prefix + (++i > 1 ? String(i) : \"\");\r\n\t\t} while (this.$[n]);\r\n\t\t// memoize next likely-unique id tag for this prefix\r\n\t\tthis._componentNameMap[prefix] = Number(i);\r\n\t\t// set and return\r\n\t\treturn inComponent.name = n;\r\n\t},\r\n\t/**\r\n\t\tAdds _inComponent_ to the list of components owned by the current\r\n\t\tcomponent (i.e., _this.$_).\r\n\t*/\r\n\taddComponent: function(inComponent) {\r\n\t\tvar n = inComponent.getName();\r\n\t\tif (!n) {\r\n\t\t\tn = this.nameComponent(inComponent);\r\n\t\t}\r\n\t\tif (this.$[n]) {\r\n\t\t\tthis.warn('Duplicate component name \"' + n + '\" in owner \"' + this.id + '\" violates unique-name-under-owner rule, replacing existing component in the hash and continuing, but this is an error condition and should be fixed.');\r\n\t\t\t//if (this.shouldWarn()) {\r\n\t\t\t/*\r\n\t\t\ttry {\r\n\t\t\t\tthrow new Error('Duplicate component name \"' + n + '\" violates unique-name-under-owner rule, replacing existing component in the hash and continuing, but this is an error condition and should be fixed.');\r\n\t\t\t} catch(x) {\r\n\t\t\t\tenyo.warn(x);\r\n\t\t\t\tenyo.log(x.stack);\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t/*this.warn() &&*/ //enyo.warn('Duplicate component name \"' + n + '\" violates unique-name-under-owner rule, replacing existing component in the hash and continuing, but this is an error condition and should be fixed.');\r\n\t\t\t//}\r\n\t\t}\r\n\t\tthis.$[n] = inComponent;\r\n\t},\r\n\t//* Removes _inComponent_ from the list of components owned by the current\r\n\t//* component (i.e., _this.$_).\r\n\tremoveComponent: function(inComponent) {\r\n\t\tdelete this.$[inComponent.getName()];\r\n\t},\r\n\t//* @public\r\n\t/**\r\n\t\tReturns an array of owned components; in other words, converts the _$_\r\n\t\thash into an array and returns the array.\r\n\t*/\r\n\tgetComponents: function() {\r\n\t\tvar results = [];\r\n\t\tfor (var n in this.$) {\r\n\t\t\tresults.push(this.$[n]);\r\n\t\t}\r\n\t\treturn results;\r\n\t},\r\n\t//* @protected\r\n\tadjustComponentProps: function(inProps) {\r\n\t\tif (this.defaultProps) {\r\n\t\t\tenyo.mixin(inProps, this.defaultProps);\r\n\t\t}\r\n\t\tinProps.kind = inProps.kind || inProps.isa || this.defaultKind;\r\n\t\tinProps.owner = inProps.owner || this;\r\n\t},\r\n\t_createComponent: function(inInfo, inMoreInfo) {\r\n\t\tif (!inInfo.kind && (\"kind\" in inInfo)) {\r\n\t\t\tthrow \"enyo.create: Attempt to create a null kind. Check dependencies for [\" + inInfo.name + \"].\";\r\n\t\t}\r\n\t\t// CAVEAT: inInfo and inMoreInfo are copied before mutation, but it's only a shallow copy\r\n\t\tvar props = enyo.mixin(enyo.clone(inMoreInfo), inInfo);\r\n\t\tthis.adjustComponentProps(props);\r\n\t\treturn enyo.Component.create(props);\r\n\t},\r\n\t//* @public\r\n\t/**\r\n\t\tCreates and returns a component as defined by the combination of\r\n\t\t_inInfo_ and _inMoreInfo_. Properties in _inInfo_ override properties in\r\n\t\t_inMoreInfo_.\r\n\r\n\t\tThe created component passes through initialization machinery provided\r\n\t\tby the creating component, which may supply special handling.\r\n\t\tUnless the owner is explicitly specified, the new component will be\r\n\t\towned by the instance on which _createComponent_ is called.\r\n\r\n\t\t\t// Create a new component named _dynamic_ owned by _this_\r\n\t\t\t// (will be available as this.$.dynamic).\r\n\t\t\tthis.createComponent({name: \"dynamic\"});\r\n\r\n\t\t\t// Create a new component named _another_ owned by _other_\r\n\t\t\t// (will be available as other.$.another).\r\n\t\t\tthis.createComponent({name: \"another\"}, {owner: other});\r\n\t*/\r\n\tcreateComponent: function(inInfo, inMoreInfo) {\r\n\t\t// createComponent and createComponents both delegate to the protected method (_createComponent),\r\n\t\t// allowing overrides to customize createComponent and createComponents separately.\r\n\t\treturn this._createComponent(inInfo, inMoreInfo);\r\n\t},\r\n\t/**\r\n\t\tCreates Components as defined by the array of configurations _inInfos_.\r\n\t\tEach configuration in _inInfos_ is combined with _inCommonInfo_ as\r\n\t\tdescribed in _createComponent_.\r\n\r\n\t\t_createComponents_ returns an array of references to the created components.\r\n\r\n\t\t\t// ask foo to create components _bar_ and _zot_, but set the owner of\r\n\t\t\t// both components to _this_.\r\n\t\t\tthis.$.foo.createComponents([\r\n\t\t\t\t{name: \"bar\"},\r\n\t\t\t\t{name: \"zot\"}\r\n\t\t\t], {owner: this});\r\n\t*/\r\n\tcreateComponents: function(inInfos, inCommonInfo) {\r\n\t\tif (inInfos) {\r\n\t\t\tvar cs = [];\r\n\t\t\tfor (var i=0, ci; (ci=inInfos[i]); i++) {\r\n\t\t\t\tcs.push(this._createComponent(ci, inCommonInfo));\r\n\t\t\t}\r\n\t\t\treturn cs;\r\n\t\t}\r\n\t},\r\n\t//* @protected\r\n\tgetBubbleTarget: function() {\r\n\t\treturn this.owner;\r\n\t},\r\n\t//* @public\r\n\t/**\r\n\t\tBubbles an event up an object chain, starting with _this_.\r\n\r\n\t\tIf a handler for this event returns true (aka _handled_),\r\n\t\tbubbling is stopped.\r\n\r\n\t\tHandlers always have this signature:\r\n\r\n\t\t\tfunction(inSender, inEvent)\r\n\r\n\t\twhere _inSender_ refers to the Component that most recently\r\n\t\tpropagated the event and _inEvent_ is an object containing\r\n\t\tevent information.\r\n\r\n\t\t_inEvent_ will have at least one property, _originator_, which\r\n\t\treferences the component that triggered the event in the first place.\r\n\t*/\r\n\tbubble: function(inEventName, inEvent, inSender) {\r\n\t\tvar e = inEvent || {};\r\n\t\t// FIXME: is this the right place?\r\n\t\tif (!(\"originator\" in e)) {\r\n\t\t\te.originator = inSender || this;\r\n\t\t\t// FIXME: use indirection here?\r\n\t\t\t//e.delegate = e.originator.delegate || e.originator.owner;\r\n\t\t}\r\n\t\treturn this.dispatchBubble(inEventName, e, inSender);\r\n\t},\r\n\t/**\r\n\t\tBubbles an event up an object chain, starting <b>above</b> _this_.\r\n\r\n\t\tIf a handler for this event returns true (aka _handled_),\r\n\t\tbubbling is stopped.\r\n\r\n\t\tHandlers always have this signature:\r\n\r\n\t\t\tfunction(inSender, inEvent)\r\n\r\n\t\twhere _inSender_ refers to the Component that most recently\r\n\t\tpropagated the event and _inEvent_ is an object containing\r\n\t\tevent information.\r\n\r\n\t\t_inEvent_ will have at least one property, _originator_, which\r\n\t\treferences the component that triggered the event in the first place.\r\n\t*/\r\n\tbubbleUp: function(inEventName, inEvent, inSender) {\r\n\t\t// Bubble to next target\r\n\t\tvar next = this.getBubbleTarget();\r\n\t\tif (next) {\r\n\t\t\treturn next.dispatchBubble(inEventName, inEvent, this);\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\t//* @protected\r\n\t/**\r\n\t\tDispatching refers to sending an event to a named delegate.\r\n\t\tThis object may dispatch an event to itself via a handler,\r\n\t\tor to its owner via an event property, e.g.:\r\n\r\n\t\t\thandlers {\r\n\t\t\t\t// 'tap' events dispatched to this.tapHandler\r\n\t\t\t\tontap: \"tapHandler\"\r\n\t\t\t}\r\n\r\n\t\t\t// 'tap' events dispatched to 'tapHandler' delegate in this.owner\r\n\t\t\tontap: \"tapHandler\"\r\n\t*/\r\n\tdispatchEvent: function(inEventName, inEvent, inSender) {\r\n\t\t// bottleneck event decoration\r\n\t\tthis.decorateEvent(inEventName, inEvent, inSender);\r\n\t\t//\r\n\t\t// Note: null checks and sub-expressions are unrolled in this\r\n\t\t// high frequency method to reduce call stack in the 90% case.\r\n\t\t// These expressions should fail early.\r\n\t\t//\r\n\t\t// try to dispatch this event directly via handlers\r\n\t\t//\r\n\t\tif (this.handlers[inEventName] && this.dispatch(this.handlers[inEventName], inEvent, inSender)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//\r\n\t\t// try to delegate this event to our owner via event properties\r\n\t\t//\r\n\t\tif (this[inEventName]) {\r\n\t\t\treturn this.bubbleDelegation(this.owner, this[inEventName], inEventName, inEvent, this);\r\n\t\t}\r\n\t},\r\n\t// internal - try dispatching event to self, if that fails bubble it up the tree\r\n\tdispatchBubble: function(inEventName, inEvent, inSender) {\r\n\t\t// Try to dispatch from here, stop bubbling on truthy return value\r\n\t\tif (this.dispatchEvent(inEventName, inEvent, inSender)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// Bubble to next target\r\n\t\treturn this.bubbleUp(inEventName, inEvent, inSender);\r\n\t},\r\n\tdecorateEvent: function(inEventName, inEvent, inSender) {\r\n\t\t// an event may float by us as part of a dispatchEvent chain or delegateEvent\r\n\t\t// both call this method so intermediaries can decorate inEvent\r\n\t},\r\n\tbubbleDelegation: function(inDelegate, inName, inEventName, inEvent, inSender) {\r\n\t\t// next target in bubble sequence\r\n\t\tvar next = this.getBubbleTarget();\r\n\t\tif (next) {\r\n\t\t\treturn next.delegateEvent(inDelegate, inName, inEventName, inEvent, inSender);\r\n\t\t}\r\n\t},\r\n\tdelegateEvent: function(inDelegate, inName, inEventName, inEvent, inSender) {\r\n\t\t// override this method to play tricks with delegation\r\n\t\t// bottleneck event decoration\r\n\t\tthis.decorateEvent(inEventName, inEvent, inSender);\r\n\t\t// by default, dispatch this event if we are in fact the delegate\r\n\t\tif (inDelegate == this) {\r\n\t\t\treturn this.dispatch(inName, inEvent, inSender);\r\n\t\t}\r\n\t\treturn this.bubbleDelegation(inDelegate, inName, inEventName, inEvent, inSender);\r\n\t},\r\n\t//* @public\r\n\t/**\r\n\t\tDispatches the event to named delegate _inMethodName_, if it exists.\r\n\t\tSubkinds may re-route dispatches.\r\n\t\tNote that both 'handlers' events and events delegated from owned controls\r\n\t\tarrive here. If you need to handle these differently, you may\r\n\t\tneed to also override _dispatchEvent_.\r\n\t*/\r\n\tdispatch: function(inMethodName, inEvent, inSender) {\r\n\t\tvar fn = inMethodName && this[inMethodName];\r\n\t\tif (fn) {\r\n\t\t\treturn fn.call(this, inSender || this, inEvent);\r\n\t\t}\r\n\t},\r\n\t/**\r\n\t\tSends a message to myself and all of my components.\r\n\t\tYou can stop a waterfall into components owned by a\r\n\t\treceiving object by returning a truthy value from\r\n\t\tthe event handler.\r\n\t*/\r\n\twaterfall: function(inMessageName, inMessage, inSender) {\r\n\t\t//this.log(inMessageName, (inSender || this).name, \"=>\", this.name);\r\n\t\tif (this.dispatchEvent(inMessageName, inMessage, inSender)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tthis.waterfallDown(inMessageName, inMessage, inSender || this);\r\n\t},\r\n\t/**\r\n\t\tSends a message to all of my components, but not myself.\r\n\t\tYou can stop a waterfall into components owned by a\r\n\t\treceiving object by returning a truthy value from\r\n\t\tthe event handler.\r\n\t*/\r\n\twaterfallDown: function(inMessageName, inMessage, inSender) {\r\n\t\tfor (var n in this.$) {\r\n\t\t\tthis.$[n].waterfall(inMessageName, inMessage, inSender);\r\n\t\t}\r\n\t}\r\n});\r\n\r\n//* @protected\r\n\r\nenyo.defaultCtor = enyo.Component;\r\n\r\n// a method to create new instances from config objects.  It handles looking up the proper\r\n// constructor based on the provided kind attribute.\r\nenyo.create = enyo.Component.create = function(inConfig) {\r\n\tif (!inConfig.kind && (\"kind\" in inConfig)) {\r\n\t\tthrow \"enyo.create: Attempt to create a null kind. Check dependencies for [\" + (inConfig.name || \"\") + \"].\";\r\n\t}\r\n\tvar kind = inConfig.kind || inConfig.isa || enyo.defaultCtor;\r\n\tvar ctor = enyo.constructorForKind(kind);\r\n\tif (!ctor) {\r\n\t\tenyo.error('no constructor found for kind \"' + kind + '\"');\r\n\t\tctor = enyo.Component;\r\n\t}\r\n\treturn new ctor(inConfig);\r\n};\r\n\r\nenyo.Component.subclass = function(ctor, props) {\r\n\t// Note: to reduce API surface area, sub-components are declared only as\r\n\t// 'components' in both kind and instance declarations.\r\n\t//\r\n\t// However, 'components' from kind declarations must be handled separately\r\n\t// at create-time.\r\n\t//\r\n\t// We rename the property here to avoid having\r\n\t// to interrogate the prototype at create-time.\r\n\t//\r\n\tvar proto = ctor.prototype;\r\n\t//\r\n\tif (props.components) {\r\n\t\tproto.kindComponents = props.components;\r\n\t\tdelete proto.components;\r\n\t}\r\n\t//\r\n\t// handlers are merged with supertype handlers\r\n\t// and kind time.\r\n\t//\r\n\tif (props.handlers) {\r\n\t\tvar kh = proto.kindHandlers;\r\n\t\tproto.kindHandlers = enyo.mixin(enyo.clone(kh), proto.handlers);\r\n\t\tproto.handlers = null;\r\n\t}\r\n\t// events property defines published events for Component kinds\r\n\tif (props.events) {\r\n\t\tthis.publishEvents(ctor, props);\r\n\t}\r\n};\r\n\r\nenyo.Component.publishEvents = function(ctor, props) {\r\n\tvar es = props.events;\r\n\tif (es) {\r\n\t\tvar cp = ctor.prototype;\r\n\t\tfor (var n in es) {\r\n\t\t\tthis.addEvent(n, es[n], cp);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nenyo.Component.addEvent = function(inName, inValue, inProto) {\r\n\tvar v, fn;\r\n\tif (!enyo.isString(inValue)) {\r\n\t\tv = inValue.value;\r\n\t\tfn = inValue.caller;\r\n\t} else {\r\n\t\tif (inName.slice(0, 2) != 'on') {\r\n\t\t\tenyo.warn(\"enyo.Component.addEvent: event names must start with 'on'. \" + inProto.kindName + \" event '\" + inName + \"' was auto-corrected to 'on\" + inName + \"'.\");\r\n\t\t\tinName = \"on\" + inName;\r\n\t\t}\r\n\t\tv = inValue;\r\n\t\tfn = \"do\" + enyo.cap(inName.slice(2));\r\n\t}\r\n\tinProto[inName] = v;\r\n\tif (!inProto[fn]) {\r\n\t\tinProto[fn] = function(inEvent) {\r\n\t\t\t// bubble this event\r\n\t\t\treturn this.bubble(inName, inEvent);\r\n\t\t};\r\n\t\t// NOTE: Mark this function as a generated event handler to allow us to\r\n\t\t// do event chaining. Is this too complicated?\r\n\t\t//inProto[fn]._dispatcher = true;\r\n\t}\r\n};\r\n\r\nenyo.Component.prefixFromKindName = function(inKindName) {\r\n\tvar prefix = enyo.Component._kindPrefixi[inKindName];\r\n\tif (!prefix) {\r\n\t\t// memoize naming information for this kind\r\n\t\tvar l = inKindName.lastIndexOf(\".\");\r\n\t\tprefix = (l >= 0) ? inKindName.slice(l+1) : inKindName;\r\n\t\t// lower-case the leading char\r\n\t\tprefix = prefix.charAt(0).toLowerCase() + prefix.slice(1);\r\n\t\t// memoize result\r\n\t\tenyo.Component._kindPrefixi[inKindName] = prefix;\r\n\t}\r\n\treturn prefix;\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":19137}]],"length":19137}
