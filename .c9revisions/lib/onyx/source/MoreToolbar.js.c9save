{"ts":1350494412503,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n\t_onyx.MoreToolbar_ extends <a href=\"#enyo.Control\">enyo.Control</a>,\n\tproviding a toolbar that can adapt to different screen sizes by moving\n\toverflowing controls and content into an <a href=\"#onyx.Menu\">onyx.Menu</a>.\n\n\t\t{kind: \"onyx.MoreToolbar\", components: [\n\t\t\t{content: \"More Toolbar\", unmoveable: true},\n\t\t\t{kind: \"onyx.Button\", content: \"Alpha\"},\n\t\t\t{kind: \"onyx.Button\", content: \"Beta\"},\n\t\t\t{kind: \"onyx.Button\", content: \"Gamma\", unmoveable: true},\n\t\t\t{kind: \"onyx.Button\", content: \"Epsilon\"}\n\t\t]},\n\n\tYou may prevent a control from being moved into the menu by setting its\n\t_unmoveable_ property to true (the default is false).\n\n\tFor more information, see the documentation on\n\t<a href=\"https://github.com/enyojs/enyo/wiki/Toolbars\">Toolbars</a> in the\n\tEnyo Developer Guide.\n*/\n\nenyo.kind({\n\tname: \"onyx.MoreToolbar\",\n\t//* @public\n\tclasses: \"onyx-toolbar onyx-more-toolbar\",\n\t//* Style class to be applied to the menu\n\tmenuClass: \"\",\n\t//* Style class to be applied to individual controls moved from the toolbar to the menu\n\tmovedClass: \"\",\n\t//* @protected\n\tlayoutKind: \"FittableColumnsLayout\",\n\tnoStretch: true,\n\thandlers: {\n\t\tonHide: \"reflow\"\n\t},\n\tpublished: {\n\t\t//* Layout kind that will be applied to the client controls.\n\t\tclientLayoutKind: \"FittableColumnsLayout\"\n\t},\n\ttools: [\n\t\t{name: \"client\", fit: true, classes: \"onyx-toolbar-inline\"},\n\t\t{name: \"nard\", kind: \"onyx.MenuDecorator\", showing: false, onActivate: \"activated\", components: [\n\t\t\t{kind: \"onyx.IconButton\", classes: \"onyx-more-button\"},\n\t\t\t{name: \"menu\", kind: \"onyx.Menu\", scrolling:false, classes: \"onyx-more-menu\", prepend: true}\n\t\t]}\n\t],\n\tinitComponents: function() {\n\t\tif(this.menuClass && this.menuClass.length>0 && !this.$.menu.hasClass(this.menuClass)) {\n\t\t\tthis.$.menu.addClass(this.menuClass);\n\t\t}\n\t\tthis.createChrome(this.tools);\n\t\tthis.inherited(arguments);\n\t\tthis.$.client.setLayoutKind(this.clientLayoutKind);\n\t},\n\tclientLayoutKindChanged: function(){\n\t\tthis.$.client.setLayoutKind(this.clientLayoutKind);\n\t},\n\treflow: function() {\n\t\tthis.inherited(arguments);\n\t\tif (this.isContentOverflowing()) {\n\t\t\tthis.$.nard.show();\n\t\t\tif (this.popItem()) {\n\t\t\t\tthis.reflow();\n\t\t\t}\n\t\t} else if (this.tryPushItem()) {\n\t\t\tthis.reflow();\n\t\t} else if (!this.$.menu.children.length) {\n\t\t\tthis.$.nard.hide();\n\t\t\tthis.$.menu.hide();\n\t\t}\n\t},\n\tactivated: function(inSender, inEvent) {\n\t\tthis.addRemoveClass(\"active\",inEvent.originator.active);\n\t},\n\tpopItem: function() {\n\t\tvar c = this.findCollapsibleItem();\n\t\tif (c) {\n\t\t\t//apply movedClass is needed\n\t\t\tif(this.movedClass && this.movedClass.length>0 && !c.hasClass(this.movedClass)) {\n\t\t\t\tc.addClass(this.movedClass);\n\t\t\t}\n\t\t\tthis.$.menu.addChild(c);\n\t\t\tvar p = this.$.menu.hasNode();\n\t\t\tif (p && c.hasNode()) {\n\t\t\t\tc.insertNodeInParent(p);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tpushItem: function() {\n\t\tvar c$ = this.$.menu.children;\n\t\tvar c = c$[0];\n\t\tif (c) {\n\t\t\t//remove any applied movedClass\n\t\t\tif(this.movedClass && this.movedClass.length>0 && c.hasClass(this.movedClass)) {\n\t\t\t\tc.removeClass(this.movedClass);\n\t\t\t}\n\t\t\tthis.$.client.addChild(c);\n\t\t\tvar p = this.$.client.hasNode();\n\t\t\tif (p && c.hasNode()) {\n\t\t\t\tvar nextChild = undefined;\n\t\t\t\tvar currIndex;\n\t\t\t\tfor(var i=0; i<this.$.client.children.length; i++) {\n\t\t\t\t\tvar curr = this.$.client.children[i];\n\t\t\t\t\tif(curr.toolbarIndex!=undefined && curr.toolbarIndex!=i) {\n\t\t\t\t\t\tnextChild = curr;\n\t\t\t\t\t\tcurrIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nextChild && nextChild.hasNode()) {\n\t\t\t\t\tc.insertNodeInParent(p, nextChild.node);\n\t\t\t\t\tvar newChild = this.$.client.children.pop();\n\t\t\t\t\tthis.$.client.children.splice(currIndex, 0, newChild);\n\t\t\t\t} else {\n\t\t\t\t\tc.appendNodeToParent(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\ttryPushItem: function() {\n\t\tif (this.pushItem()) {\n\t\t\tif (!this.isContentOverflowing()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.popItem();\n\t\t\t}\n\t\t}\n\t},\n\tisContentOverflowing: function() {\n\t\tif (this.$.client.hasNode()) {\n\t\t\tvar c$ = this.$.client.children;\n\t\t\tvar n = c$[c$.length-1].hasNode();\n\t\t\tif(n) {\n\t\t\t\tthis.$.client.reflow();\n\t\t\t\t//Workaround: scrollWidth value not working in Firefox, so manually compute\n\t\t\t\t//return (this.$.client.node.scrollWidth > this.$.client.node.clientWidth);\n\t\t\t\treturn ((n.offsetLeft + n.offsetWidth) > this.$.client.node.clientWidth);\n\t\t\t}\n\t\t}\n\t},\n\tfindCollapsibleItem: function() {\n\t\tvar c$ = this.$.client.children;\n\t\tfor (var i=c$.length-1; c=c$[i]; i--) {\n\t\t\tif (!c.unmoveable) {\n\t\t\t\treturn c;\n\t\t\t} else {\n\t\t\t\tif(c.toolbarIndex==undefined) {\n\t\t\t\t\tc.toolbarIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":4532}]],"length":4532}
{"contributors":[],"silentsave":false,"ts":1350494448259,"patch":[[{"diffs":[[0,"t: true,"],[1," noStretch: true,"],[0," classes"]],"start1":1322,"start2":1322,"length1":16,"length2":33}]],"length":4549,"saved":false}
